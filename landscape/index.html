<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <style>

    svg {
      cursor: grab;
    }

    svg:active {
      cursor: grabbing;
    }

    .node {
      cursor: pointer;
    }
    .node .label {
      opacity: 0;
      transition: opacity .5s;
      pointer-events: none;
      font-family: sans-serif;
    }

    .node circle {
      /* shape-rendering: optimizeSpeed; */
    }
    .node:hover circle {
      /* fill:white; */
    }
    .node:hover .label {
      opacity: 1;
    }
    .g-circles {

    }
    .g-circles circle {

    }
  </style>
</head>
<body>
  <svg id="landscape">
    <defs>
      <filter id="goo">
        <feGaussianBlur in="SourceGraphic" stdDeviation="18" result="blur"></feGaussianBlur>
        <feColorMatrix in="blur" mode="matrix" result="mat" values="1 0 0 0 0  0 1 0 0 0  0 0 1 0 0  0 0 0 50 -19"></feColorMatrix>
      </filter>
    </defs>
  </svg>
  <!-- <p>Schiaccia "y" per colorare per anno, "c" per colorare per raccolta. "n" per evidenziare le opere della nebbia, "m" per cancellazione. Barra spaziatrice per tutte le opere.</p> -->
  <script src="https://d3js.org/d3.v5.js"></script>
  <!-- <script src="metaball.js"></script> -->
  <script type="text/javascript">

    let data = {

      allowedCollections: "all" // all : all collections; undefined for texts with undefined collection; V002,V014 (no spaces) for setting some collection ids for filtering (you can also put undefined in this list)

    };

    // Warn if overriding existing method
    if(Array.prototype.equals)
        console.warn("Overriding existing Array.prototype.equals. Possible causes: New API defines the method, there's a framework conflict or you've got double inclusions in your code.");
    // attach the .equals method to Array's prototype to call it on any array
    Array.prototype.equals = function (array) {
        // if the other array is a falsy value, return
        if (!array)
            return false;

        // compare lengths - can save a lot of time 
        if (this.length != array.length)
            return false;

        for (var i = 0, l=this.length; i < l; i++) {
            // Check if we have nested arrays
            if (this[i] instanceof Array && array[i] instanceof Array) {
                // recurse into the nested arrays
                if (!this[i].equals(array[i]))
                    return false;       
            }           
            else if (this[i] != array[i]) { 
                // Warning - two different object instances will never be equal: {x:20} != {x:20}
                return false;   
            }           
        }       
        return true;
    }

    // Hide method from for-in loops
    Object.defineProperty(Array.prototype, "equals", {enumerable: false});        

    Array.prototype.includesArray = function(array)
    {
      if(!array) return false;

      for(let i = 0, l=this.length; i < l; ++i)
      {
        if(this[i].equals(array)) return true;
      }

      return false;
    }

    Object.defineProperty(Array.prototype, "includesArray", {enumerable: false});    

    d3
      .csv("donuts_data.csv")
      .then(
        function(csv)
        {
          data.x_csv2 = csv.reduce(
            function(map, obj)
            {
              map[obj.id] = calculate_item_data(obj);

              return map;
            },
            {});

          d3
            .json("data.json")
            .then(treat_json);
        });

    function treat_json(json)
    {
      let collections = getCollections();
      let allowedCollections = data.allowedCollections.split(",");

//      let json_nodes = json.nodes;
//      let json_nodes = json.nodes.slice(0, 3)
      let json_nodes = json.nodes.filter(function(item) {
//      let check1 = data.allowedCollections == "all";
//      let check2 = (allowedCollections.includes("undefined") && item.attributes.collections == undefined);
//      let check3 = array_intersection(allowedCollections, item.attributes.collections).length > 0

        return (
//          item.attributes.collections != undefined
//          && item.attributes.collections.includes("V014")
            data.allowedCollections == "all" ||
            (allowedCollections.includes("undefined") && item.attributes.collections == undefined) ||
            array_intersection(allowedCollections, item.attributes.collections).length > 0
        );
      });

      json_nodes.forEach(
        function(n)
        {
          // fix orientation of the viz
          // n.y*=-1;
          n.x*=-1;
          // handle collections
          if (n.attributes.collections){
            n.attributes.collections = n.attributes.collections.split(';')
            // remove last element which is always empty due to the fact that all records end with a ";"
            n.attributes.collections.pop()
          } else {
            n.attributes.collections = []
          }
        });

      // sort node so to have the upper in the background and not covering the ones in the foreground
      json_nodes = json_nodes.sort(function(a, b){return a.y - b.y});

      // calculate the size of steps for hills
      let size_ext = d3.extent(json.nodes, function(d){return d.size});
      data.min_size = size_ext[0]/8;
      let step_increment = -23;

      json_nodes.forEach(create_item_steps);      

      json_nodes.forEach(node => 
        node.steps.forEach(step => 
          collections.forEach(coll => {
            checkMapAndInsert(step, "metaballCorner", coll.id, false)
            let x = 6;
          })));

      collections
//        .filter(coll => coll.id == "V014")
        .filter(coll => data.allowedCollections == "all" || allowedCollections.includes(coll.id))
        .forEach(coll => prepareMetaballData(json_nodes, coll.id, coll.c));

      let margin = {
        "min_x": d3.min(json_nodes, function(d){ return d.x }),
        "max_x": d3.max(json_nodes, function(d){ return d.x }),
        "min_y": d3.min(json_nodes, function(d){ return d.y }),
        "max_y": d3.max(json_nodes, function(d){ return d.y })
      };

      let colour = d3
        .scaleLinear()
        .domain(d3.extent(json_nodes, function(d){ return d.attributes.first_publication; }))
        .range(['#ff6347','#455A64']);

      let col_collections = d3
        .scaleOrdinal()
        .domain(collections.map(function(d){return d.id}))
        .range(collections.map(function(d){return d.c}))
        .unknown('#ffffff');

      let w = window.innerWidth-20
      let h = window.innerHeight-20
      let svg = d3
        .select('svg')
        .attr('width', w)
        .attr('height', h)
        .style('background-color','#e4e4e4')
        .style('background-color','#EFEBE9');            

      let radialGradient = svg
        .append("defs")
        .append("radialGradient")
        .attr("id", "radial-gradient")
        
      radialGradient
        .append("stop")
        .attr("offset", "30%")
        .attr("stop-color", "green")            

      radialGradient
        .append("stop")
        .attr("offset", "97%")
        .attr("stop-color", "#EFEBE9")            

      let svg_main_group = svg
        .append('g');

//      let flattened_steps = flatten_items_steps(json_nodes);        

      let metaball_group = svg_main_group
        .append("g")
        .attr("class", "metaball_nodes");

      let metaball_nodes = metaball_group
        .selectAll(".metaball_node")
        .data(json_nodes)
        .enter()
          .append("g")
          .attr("class", "metaball_node")
          .attr("transform", function(d) {
            return 'scale(1,0.5773) translate('+d.x+','+d.y+')'
          });

      let metaballs = metaball_nodes
        .selectAll(".metaball")
        .data((d, i) => {
          return d.steps;
        })
        .enter();

      collections.forEach(coll =>
        metaballs
          .filter(function(d) { 
            return d.metaballCorner[coll.id]; 
          })
          .append("svg:path")
          .attr("class", function(d) {
            return "metaball collection_" + coll.id;
          })
          .attr("d", function(d) {
            return d.lobe[coll.id];
          })
          .attr("fill", "none")
          .attr("stroke", function(d) {
            return d.lobeColor[coll.id];
          })
          .attr("stroke-opacity", 0)
          .attr("stroke-width", 30)
          .attr('transform',function(d){
            let delta_x = -(+d.x);
            let delta_y = -(+d.y);
            return 'translate(' + delta_x + ', ' + delta_y + ')'
          }));

/////////////////

      let g = svg_main_group
        .append('g')
        .attr('class','nodes');

      // Text nodes (single text-related features such as hills, donuts, ...)
      let text_nodes = g
        .selectAll('.node')
        .data(json_nodes)
        .enter()
          .append('g')
          .attr('class','node')
          .attr('transform',function(d){
            return 'scale(1,0.5773) translate('+d.x+','+d.y+')'
          });

//      let xxx = json_nodes.map(node => node.steps);

      let steps = text_nodes
        .selectAll('circle')
//        .data(create_item_steps)
//        .data(flattened_steps)
//        .data(xxx)
        .data((d, i) => { 
          return d.steps; 
        })
        .enter();

      steps
        .filter(function(d) { return d.first_elem; })
//        .enter()
        .append('circle')
//              .attr('stroke','green')
//              .attr('stroke-width',1.5)
        .attr('fill','url(#radial-gradient)')
        .attr('r',function(d){ return d.r * 1.5 })
        .attr("class", "halo")              
        .style('fill-opacity',0)
        .style('stroke-opacity',0)
        .attr('transform', function(d,i){
          i = i*step_increment
          return 'translate(0,'+i+')'
        });

/*        .attr('transform', function(d,i){
          i = i*step_increment
          return 'translate(0,'+i+')'
        });;
*/
/*
svg
  .append("circle")
  .attr("cx", 100)
  .attr("cy", 100)
  .attr("r", 30);
*/

      steps
//        .enter()
        .append('circle')
        .attr('stroke','#444')
        .attr('stroke-width',1.5)
        .attr('fill',function(d){
          return colour(d.first_publication);
        })
        .attr('r',function(d){ return d.r })
        .attr('first_elem',function(d){ return d.first_elem })
        .attr("class", "hill" ) 
        .style('fill-opacity',0)
        .style('stroke-opacity',0)
        .transition()
        .duration(1000)
        .delay(function(d){return (d.first_publication - 1940)*100})
        .attr('transform', function(d,i){
          i = i*step_increment
          return 'translate(0,'+i+')'
        })              
        .style('fill-opacity',1)
        .style('stroke-opacity',1);

/*
      steps
        .enter()
        .append("circle")
        .attr("cx", 100)
        .attr("cx", 100)
        .attr("r", 30);
*/

      let PI = Math.PI;
      let arcMin = 75; // inner radius of the first arc
      let arcWidth = 15;
      let arcPad = 1; // padding between arcs
      let drawMode = 1; // 1 : hills; 2 : hills with halo; 3 : places; 4 : dubitative phenomena;
      let metaballsVisible = new Map();

      let drawPlacesArc1 = d3
        .arc()
        .innerRadius(function(d, i) {
            return d.r - (i+1) * arcWidth + arcPad;
        })
        .outerRadius(function(d, i) {
            return d.r - i * arcWidth;
        })
        .startAngle(0 * 2 * PI)
        .endAngle(function(d, i) {
            return d.generico_non_terrestre * 2 * PI;
        });

      let drawPlacesArc2 = d3
        .arc()
        .innerRadius(function(d, i) {
            return d.r - (i+1) * arcWidth + arcPad;
        })
        .outerRadius(function(d, i) {
            return d.r - i * arcWidth;
        })
        .startAngle(function(d, i) {
            return d.generico_non_terrestre * 2 * PI;
        })
        .endAngle(function(d, i) {
            return d.generico_terrestre * 2 * PI;
        });

      let drawPlacesArc3 = d3
        .arc()
        .innerRadius(function(d, i) {
            return d.r - (i+1) * arcWidth + arcPad;
        })
        .outerRadius(function(d, i) {
            return d.r - i * arcWidth;
        })
        .startAngle(function(d, i) {
            return d.generico_terrestre * 2 * PI;
        })
        .endAngle(function(d, i) {
            return d.inventato * 2 * PI;
        });          

      let drawPlacesArc4 = d3
        .arc()
        .innerRadius(function(d, i) {
            return d.r - (i+1) * arcWidth + arcPad;
        })
        .outerRadius(function(d, i) {
            return d.r - i * arcWidth;
        })
        .startAngle(function(d, i) {
            return d.inventato * 2 * PI;
        })
        .endAngle(function(d, i) {
            return d.no_ambientazione * 2 * PI;
        });

      let drawPlacesArc5 = d3
        .arc()
        .innerRadius(function(d, i) {
            return d.r - (i+1) * arcWidth + arcPad;
        })
        .outerRadius(function(d, i) {
            return d.r - i * arcWidth;
        })
        .startAngle(function(d, i) {
            return d.no_ambientazione * 2 * PI;
        })
        .endAngle(function(d, i) {
            return d.nominato_non_terrestre * 2 * PI;
        });         

      let drawPlacesArc6 = d3
        .arc()
        .innerRadius(function(d, i) {
            return d.r - (i+1) * arcWidth + arcPad;
        })
        .outerRadius(function(d, i) {
            return d.r - i * arcWidth;
        })
        .startAngle(function(d, i) {
            return d.nominato_non_terrestre * 2 * PI;
        })
        .endAngle(function(d, i) {
            return d.nominato_terrestre * 2 * PI;
        });

      let drawPlacesArc7 = d3
        .arc()
        .innerRadius(function(d, i) {
            return d.r - (i+1) * arcWidth + arcPad;
        })
        .outerRadius(function(d, i) {
            return d.r - i * arcWidth;
        })
        .startAngle(function(d, i) {
            return d.nominato_terrestre * 2 * PI;
        })
        .endAngle(function(d, i) {
            return 2 * PI;
        });   

//////////////////


      steps
        .filter(function(d) { return d.first_elem } )
        .append("svg:path")
        .attr("fill", "red")
        .attr("class", "places")
        .attr("d", drawPlacesArc1)
        .attr('transform', function(d,i){
          i = i*step_increment
          return 'translate(0,'+i+')'
        })
        .style('fill-opacity',0);

      steps
        .filter(function(d) { return d.first_elem } )
        .append("svg:path")
        .attr("fill", "orange")
        .attr("class", "places")
        .attr("d", drawPlacesArc2)
        .attr('transform', function(d,i){
          i = i*step_increment
          return 'translate(0,'+i+')'
        })
        .style('fill-opacity',0);

      steps
        .filter(function(d) { return d.first_elem } )
        .append("svg:path")
        .attr("fill", "fuchsia")
        .attr("class", "places")
        .attr("d", drawPlacesArc3)
        .attr('transform', function(d,i){
          i = i*step_increment
          return 'translate(0,'+i+')'
        })
        .style('fill-opacity',0);

      steps
        .filter(function(d) { return d.first_elem } )
        .append("svg:path")
        .attr("fill", "darkgrey")
        .attr("class", "places")
        .attr("d", drawPlacesArc4)
        .attr('transform', function(d,i){
          i = i*step_increment
          return 'translate(0,'+i+')'
        })
        .style('fill-opacity',0);

      steps
        .filter(function(d) { return d.first_elem } )
        .append("svg:path")
        .attr("fill", "blue")
        .attr("class", "places")
        .attr("d", drawPlacesArc5)
        .attr('transform', function(d,i){
          i = i*step_increment
          return 'translate(0,'+i+')'
        })
        .style('fill-opacity',0);

      steps
        .filter(function(d) { return d.first_elem } )
        .append("svg:path")
        .attr("fill", "dodgerblue")
        .attr("class", "places")
        .attr("d", drawPlacesArc6)
        .attr('transform', function(d,i){
          i = i*step_increment
          return 'translate(0,'+i+')'
        })
        .style('fill-opacity',0);

      steps
        .filter(function(d) { return d.first_elem } )
        .append("svg:path")
        .attr("fill", "white")
        .attr("class", "places")
        .attr("d", drawPlacesArc7)
        .attr('transform', function(d,i){
          i = i*step_increment
          return 'translate(0,'+i+')'
        })
        .style('fill-opacity',0);

//////////////////////////////

      let drawDubitativePhenomenaArc1 = d3
        .arc()
        .innerRadius(function(d, i) {
            return d.r - (i+1) * arcWidth + arcPad;
        })
        .outerRadius(function(d, i) {
            return d.r - i * arcWidth;
        })
        .startAngle(0 * 2 * PI)
        .endAngle(function(d, i) {
            return d.nebbia * 2 * PI;
        });

      let drawDubitativePhenomenaArc2 = d3
        .arc()
        .innerRadius(function(d, i) {
            return d.r - (i+1) * arcWidth + arcPad;
        })
        .outerRadius(function(d, i) {
            return d.r - i * arcWidth;
        })
        .startAngle(function(d, i) {
            return d.nebbia * 2 * PI;
        })
        .endAngle(function(d, i) {
            return d.cancellazione * 2 * PI;
        });

      let drawDubitativePhenomenaArc3 = d3
        .arc()
        .innerRadius(function(d, i) {
            return d.r - (i+1) * arcWidth + arcPad;
        })
        .outerRadius(function(d, i) {
            return d.r - i * arcWidth;
        })
        .startAngle(function(d, i) {
            return d.cancellazione * 2 * PI;
        })
        .endAngle(function(d, i) {
            return 2 * PI;
        });       

///////

      steps
        .filter(function(d) { return d.first_elem } )
        .append("svg:path")
        .attr("fill", "blue")
        .attr("class", "dubitativePhenomena")
        .attr("d", drawDubitativePhenomenaArc1)
        .attr('transform', function(d,i){
          i = i*step_increment
          return 'translate(0,'+i+')'
        })
        .style('fill-opacity',0);

      steps
        .filter(function(d) { return d.first_elem } )
        .append("svg:path")
        .attr("fill", "red")
        .attr("class", "dubitativePhenomena")
        .attr("d", drawDubitativePhenomenaArc2)
        .attr('transform', function(d,i){
          i = i*step_increment
          return 'translate(0,'+i+')'
        })
        .style('fill-opacity',0);

      steps
        .filter(function(d) { return d.first_elem } )
        .append("svg:path")
        .attr("fill", "white")
        .attr("class", "dubitativePhenomena")
        .attr("d", drawDubitativePhenomenaArc3)
        .attr('transform', function(d,i){
          i = i*step_increment
          return 'translate(0,'+i+')'
        })
        .style('fill-opacity',0);


///////////////////////////////

      text_nodes
        .on("Xmouseenter", function(){
          d3.selectAll('.node')
            .transition()
            .duration(350)
            .style('opacity',.4)

          d3.select(this)
            .selectAll('circle')
            .transition()
            .duration(350)
            .attr('transform', function(d,i){
              i = i*step_increment*1.5
              return 'translate(0,'+i+')'
            });
        })
        .on("Xmouseleave", function(){
          d3.selectAll('.node')
            .transition()
            .duration(350)
            .style('opacity',1);

          d3.select(this).selectAll('circle')
            .transition()
            .duration(350)
            .style('opacity',1)
            .attr('transform', function(d,i){
              i = i*step_increment
              return 'translate(0,'+i+')'
            });
        });

      let label = text_nodes
        .selectAll('.label')
        .data(function(d){ return [d] })
        .enter()
          .append('text')
          .attr('class','label')
          .attr('fill','black')
          .attr('font-size','5rem')
          .attr('transform',function(d){
            return 'translate(0,'+(d.steps.length+2)*step_increment+') scale(1,'+1/0.5773+')'
          })
          .text(function(d){
            return d.id+'-'+d.attributes.first_publication;
          });

      //add zoom capabilities
      var zoom_handler = d3
        .zoom()
        .on("zoom", zoom_actions);

      zoom_handler(svg);

      svg.transition()
        .duration(0)
        .call( zoom_handler.transform, d3.zoomIdentity
          .translate(w/2,h/2*1.2)
          .scale(0.08)
        ); // updated for d3 v4

      //Zoom functions
      function zoom_actions(){
        // console.log(d3.event.transform)
        g.attr("transform", d3.event.transform);
        metaball_group.attr("transform", d3.event.transform);
      }

      d3
        .select('body')
        .on("keyup", 
          function(d) 
          {
          console.log(d3.event.key)

          let eventKey = d3.event.key.toLowerCase();

          if (eventKey == "c") {
            text_nodes.selectAll('circle')
              .transition().duration(350)
              .attr('fill',function(d){
                return col_collections(d.collection)
              })
          } else if (eventKey == "y") {
            text_nodes.selectAll('circle')
              .transition()
              .duration(350)
              .attr('fill',function(d){
                return colour(d.first_publication)
              })
          } else if (eventKey == "n") {
            text_nodes.style('display','none')
            text_nodes.filter(function(d){
                console.log(d)
                return d.attributes.nebbia
              })
              .style('display','block')
          } else if (eventKey == "m") {
            text_nodes.style('display','none')
            text_nodes.filter(function(d){
                console.log(d)
                return d.attributes.cancellazione
              })
              .style('display','block')
          } else if (eventKey == "p") {

            drawMode = incrementDrawMode(drawMode);
console.log(drawMode);

            switch(drawMode)
            {
              case 1 : // hills
                text_nodes
                  .selectAll('path')
                  .transition()
                  .duration(450)
                  .style('fill-opacity',0)
                  .style('stroke-opacity',0);

                text_nodes
                  .selectAll('.halo')
                  .transition()
                  .duration(450)
                  .style('fill-opacity',0)
                  .style('stroke-opacity',0);

                text_nodes
                  .selectAll('.hill')
                  .transition()
                  .duration(450)
                  .style('fill-opacity',1)
                  .style('stroke-opacity',1);

                text_nodes
                  .selectAll('circle')
                  .filter(function(d) { return d.first_elem && !this.classList.contains('halo'); } )
                  .transition()
                  .duration(450)
                  .style('fill-opacity',1)
                  .style('stroke-opacity',1)
                  .style('fill', function(d) 
                  { 
                    return colour(d.first_publication);
                  });                  

                break;

              case 2 : // hills with halos

                text_nodes
                  .selectAll('path')
                  .transition()
                  .duration(450)
                  .style('fill-opacity',0)
                  .style('stroke-opacity',0);

                text_nodes
                  .selectAll('circle')
                  .transition()
                  .duration(450)
                  .style('fill-opacity',1)
                  .style('stroke-opacity',1);

                break;                

              case 3 : // places

                text_nodes
                  .selectAll('.places')
                  .style('fill-opacity',1)
                  .style('stroke-opacity',1);

                text_nodes
//                  .selectAll('circle')
//                  .selectAll()
//                  .filter(function(d) { return !this.classList.contains("places"); })
                  .selectAll("circle:not(.places)")
                  .transition()
                  .duration(450)
                  .style('fill-opacity',0)
                  .style('stroke-opacity',0);

                text_nodes
                  .selectAll('circle')
                  .filter(function(d) { return d.first_elem && !this.classList.contains('halo'); } )
                  .transition()
                  .duration(450)
                  .style('fill-opacity',0.2)
                  .style('stroke-opacity',0);              

                break;

              case 4 : // dubitative phenomena

                text_nodes
                  .selectAll('.places')
                  .style('fill-opacity',0)
                  .style('stroke-opacity',0);              

                text_nodes
                  .selectAll('.dubitativePhenomena')
                  .style('fill-opacity',1)
                  .style('stroke-opacity',1);

                text_nodes
//                  .selectAll('circle')
//                  .selectAll()
//                  .filter(function(d) { return !this.classList.contains("dubitativePhenomena"); })
                  .selectAll("circle:not(.dubitativePhenomena)")
                  .transition()
                  .duration(450)
                  .style('fill-opacity',0)
                  .style('stroke-opacity',0);

                text_nodes
                  .selectAll('circle')
                  .filter(function(d) { return d.first_elem && !this.classList.contains('halo'); } )
                  .transition()
                  .duration(450)
                  .style('fill-opacity', d => sample(d.norma_pct_caratteri_nebbia_cancellazione, 0, 1, 10))
                  .style('stroke-opacity',0)
                  .style('fill', '#9900FF');
/*                  
                  .style('fill', function(d) 
                  {                     
                    let r = convertRatioToColorComponent(d.cancellazione_normalizzata);
                    let g = "00";
                    let b = convertRatioToColorComponent(d.nebbia_normalizzata);                    

                    if(r == "00" && b == "00")
                    {
                      r = "B2";
                      g = "B2";
                      b = "B2";
                    }

                    let col = "#" + r + g + b;
//                    console.log("r : " + r + "; b : " + b + "; col : " + col);
//                    return col; 
                      return "#" + r + g + b;
                  });
*/
                break;
            }
          }
          else if(eventKey == "x")
          {
            collections.forEach(coll => metaballsVisible[coll.id] = !metaballsVisible[coll.id]);

/*
            if(metaballsVisible)
            {
              metaballs
                .selectAll(".metaball")
                .transition()
                .duration(450)
                .style("stroke-opacity", 1);
            }
            else
            {
              metaballs
                .selectAll(".metaball")
                .transition()
                .duration(450)
                .style("stroke-opacity", 0);
            }
*/

              metaballs
                .selectAll(".metaball")
                .transition()
                .duration(450)
                .style("stroke-opacity", function(d) { return metaballsVisible[d.collection] ? 1 : 0; });

          }
          else if("0123456789".includes(eventKey))
          {
//            let collections = getCollections();
            let collectionId = collections[+eventKey].id;

            let collectionClass = "collection_" + collectionId;

            metaballsVisible[collectionId] = !metaballsVisible[collectionId];

            if(metaballsVisible[collectionId])
            {
              metaballs
                .selectAll(".metaball." + collectionClass)
                .transition()
                .duration(450)
                .style("stroke-opacity", 1);
            }
            else
            {
              metaballs
                .selectAll(".metaball." + collectionClass)
                .transition()
                .duration(450)
                .style("stroke-opacity", 0);
            }
          }
          else if (eventKey == " ") {
           text_nodes.style('display','block')
          }
      });
    }

    function convertRatioToColorComponent(r)
    {
      // r is assumed to be in [0, 1]
//      let s = "00" + Math.trunc(r * 255).toString(16);
      let s = "00" + Math.trunc(r * 255).toString(16);

      let s2 = s.substring(s.length - 2, s.length);

      return s2;
    }

    function sample(value, min, max, nIntervals)
    {
      const delta = max - min;
      const step = delta / nIntervals;

      let stepSum = 0;

      while(stepSum < value)
      {
        stepSum += step;
      }

      return stepSum;
    }    

    function flatten_items_steps(nodes)
    {   
      let flattened_steps = [];

      for(let i = 0; i < nodes.length; ++i)
      {
        let node = nodes[i];

        for(let j = 0; j < node.steps.length; ++j)
        {
          let step = node.steps[j];

          let item = 
          {
              id: step.id,
              x: node.x,
              y: node.y,              

              r: step.r,
              steps_length: node.steps.length,
              step: step,

              collections: node.attributes.collections,
              first_elem: step.first_elem,
              first_publication: step.first_publication,
              generico_non_terrestre: step.generico_non_terrestre,
              generico_terrestre: step.generico_terrestre,
              inventato: step.inventato,
              no_ambientazione: step.no_ambientazione,
              nominato_non_terrestre: step.nominato_non_terrestre,
              nominato_terrestre: step.nominato_terrestre,

              nebbia_normalizzata: step.nebbia_normalizzata,              
              cancellazione_normalizzata: step.cancellazione_normalizzata,

              nebbia: step.nebbia,
              cancellazione: step.cancellazione,

              norma_pct_caratteri_nebbia_cancellazione: step.norma_pct_caratteri_nebbia_cancellazione
          };

          flattened_steps.push(item);          
        }
      }

      return flattened_steps;
/*      
      let steps_collections = 
        nodes.map(
          node => node.steps.map(
            step => { 
              x: node.x; 
              y: node.y;  
              cancellazione: step.cancellazione;
              cancellazione_normalizzata: step.cancellazione_normalizzata;
              collection: step.collection;
              first_elem: step.first_elem;
              first_publication: step.first_publication;
              generico_non_terrestre: step.generico_non_terrestre;
              generico_terrestre: step.generico_terrestre;
              id: step.id;
              inventato: step.inventato;
              nebbia: step.nebbia;
              nebbia_normalizzata: step.nebbia_normalizzata;
              no_ambientazione: step.no_ambientazione;
              nominato_non_terrestre: step.nominato_non_terrestre;
              nominato_terrestre: step.nominato_terrestre;
              r: step.r
            }
          ));

      let flattened_steps = steps_collections.flat(1);      

      return flattened_steps;
*/      
    }

    function calculate_item_data(obj)
    {
      let item_data = 
      { 
        generico_non_terrestre: (+obj.generico_non_terrestre),
        generico_terrestre:     (+obj.generico_non_terrestre) + (+obj.generico_terrestre),
        inventato:              (+obj.generico_non_terrestre) + (+obj.generico_terrestre) + (+obj.inventato),
        no_ambientazione:       (+obj.generico_non_terrestre) + (+obj.generico_terrestre) + (+obj.inventato) + (+obj.no_ambientazione),
        nominato_non_terrestre: (+obj.generico_non_terrestre) + (+obj.generico_terrestre) + (+obj.inventato) + (+obj.no_ambientazione) + (+obj.nominato_non_terrestre),
        nominato_terrestre:     (+obj.generico_non_terrestre) + (+obj.generico_terrestre) + (+obj.inventato) + (+obj.no_ambientazione) + (+obj.nominato_non_terrestre) + (+obj.nominato_terrestre),

        nebbia_normalizzata:        (+obj.pct_nebbia_normalizzata),
        cancellazione_normalizzata: (+obj.pct_cancellazione_normalizzata),

        nebbia:                     (+obj.pct_nebbia / 100),
        cancellazione:              (+obj.pct_nebbia / 100) + (+obj.pct_cancellazione / 100),

        norma_pct_caratteri_nebbia_cancellazione: (+obj.norma_pct_caratteri_nebbia_cancellazione)
      };

      return item_data;
    }

    function create_item_steps(d)
    {
      // reverse the order of collections, so to have the older ones at the bottom of the hills
      d.attributes.collections = d.attributes.collections.reverse()

      d.steps = [];
      // get different radii
      for (var jj = (data.min_size); jj<= d.size; jj+=data.min_size) {
        let new_step_size = jj;
        let ratio = new_step_size / d.size;
        new_step_size = d.size * interpolateSpline(ratio);
        d.steps.push(new_step_size);
      }

      // get colors
      d.steps = d.steps.map((s,i) => {

        // assign to each step a collection
        let pos_1 = i/d.steps.length;
        let pos_2 = pos_1 * d.attributes.collections.length;
        let collection_here = d.attributes.collections[Math.floor(pos_2)]
        let first_elem = (i == (d.steps.length-1))

        let csv_item = data.x_csv2[d.id];

        return {
          'r': s, 
          'collection': collection_here, 
          'first_publication': d.attributes.first_publication, 
          'id': d.id, 
          'first_elem': first_elem,
          'generico_non_terrestre': csv_item == undefined ? 0 : csv_item.generico_non_terrestre,
          'generico_terrestre':  csv_item == undefined ? 0 : csv_item.generico_terrestre,
          'inventato':  csv_item == undefined ? 0 : csv_item.inventato,
          'no_ambientazione':  csv_item == undefined ? 0 : csv_item.no_ambientazione,
          'nominato_non_terrestre':  csv_item == undefined ? 0 : csv_item.nominato_non_terrestre,
          'nominato_terrestre':  csv_item == undefined ? 0 : csv_item.nominato_terrestre,
          'nebbia_normalizzata': csv_item == undefined ? 0 : csv_item.nebbia_normalizzata,
          'cancellazione_normalizzata': csv_item == undefined ? 0 : csv_item.cancellazione_normalizzata,
          'nebbia': csv_item == undefined ? 0 : csv_item.nebbia,
          'cancellazione': csv_item == undefined ? 0 : csv_item.cancellazione,
          'norma_pct_caratteri_nebbia_cancellazione': csv_item == undefined ? 0 : csv_item.norma_pct_caratteri_nebbia_cancellazione
        };
      });

      // sort array so to have little circles on top, big at bottom
      d.steps = d.steps.reverse();

      return d.steps;
    }

    function interpolateSpline(x) 
    {
      let y;

      // The cubic spline interpolation has been calculated "heuristically" by using this service:
      // https://tools.timodenk.com/cubic-spline-interpolation

      // Inserted values are:
      // x, y
      // 0, 0
      // 0.2, 0.25
      // 0.5, 0.5
      // 0.8, 0.75
      // 1, 1

      if (x>=0 && x<=0.2) {
        y = (-2.0833*Math.pow(x,3)) + (1.25*Math.pow(10,-61)*Math.pow(x,2)) + (1.3333*x);
      } else if (x>0.2 && x<=0.5) {
        y = (1.3889*Math.pow(x,3)) + (-2.0833*Math.pow(x,2)) + (1.75*x) + (-2.7778*Math.pow(10,-2))
      } else if (x>0.5 && x<=0.8) {
        y = (1.3889*Math.pow(x,3)) + (-2.0833*Math.pow(x,2)) + (1.75*x) + (-2.7778*Math.pow(10,-2))
      } else if (x>0.8 && x<=1) {
        y = (-2.0833*Math.pow(x,3)) + (6.25*Math.pow(x,2)) + (-4.9167*x) + (1.75)
      } else {
        y=x
      }

      // Inserted values are:
      // x, y
      // 0, 0.1
      // 0.15, 0.30
      // 0.6, 0.6
      // 0.8, 0.75
      // 1, 1

      if (x>=0 && x<=0.15) {
        y = (-4.1854*Math.pow(x,3)) + (-1.0594*Math.pow(10,-60)*Math.pow(x,2)) + (1.4275*x) + (1*Math.pow(10,-1));
      } else if (x>0.15 && x<=0.6) {
        y = (1.8233*Math.pow(x,3)) + (-2.7039*Math.pow(x,2)) + (1.8331*x) + (7.9721*Math.pow(10,-2))
      } else if (x>0.6 && x<=0.8) {
        y = (1.9208*Math.pow(x,3)) + (-2.8793*Math.pow(x,2)) + (1.9383*x) + (5.8671*Math.pow(10,-2))
      } else if (x>0.8 && x<=1) {
        y = (-2.8842*Math.pow(x,3)) + (8.6525*Math.pow(x,2)) + (-7.2871*x) + (2.5188)
      } else {
        y=x
      }

      // Inserted values are:
      // x, y
      // 0, 0
      // 0.13, 0.2
      // 0.5, 0.5
      // 0.8, 0.75
      // 1, 1

      if (x>=0 && x<=0.13) {
        y = (-6.0237*Math.pow(x,3)) + (1*Math.pow(10,-61)*Math.pow(x,2)) + (1.6403*x) + (0);
      } else if (x>0.13 && x<=0.5) {
        y = (2.5213*Math.pow(x,3)) + (-3.3326*Math.pow(x,2)) + (2.0735*x) + (-1.8773*Math.pow(10,-2))
      } else if (x>0.5 && x<=0.8) {
        y = (7.3971*Math.pow(10,-1)*Math.pow(x,3)) + (-6.6014*Math.pow(10,-1)*Math.pow(x,2)) + (7.3729*Math.pow(10,-1)*x) + (2.0393*Math.pow(10,-1))
      } else if (x>0.8 && x<=1) {
        y = (-1.8586*Math.pow(x,3)) + (5.5759*Math.pow(x,2)) + (-4.2515*x) + (1.5343)
      } else {
        y=x
      }

      // Inserted values are:
      // x, y
      // 0, 0
      // 0.1, 0.2
      // 0.55, 0.5
      // 0.8, 0.8
      // 1, 1

      if (x>=0 && x<=0.1) {
        y = (-1.6169*Math.pow(10,1)*Math.pow(x,3)) + (-8.4013*Math.pow(10,-61)*Math.pow(x,2)) + (2.1617*x) + (0);
      } else if (x>0.1 && x<=0.55) {
        y = (5.7918*Math.pow(x,3)) + (-6.5882*Math.pow(x,2)) + (2.8205*x) + (-2.1961*Math.pow(10,-2))
      } else if (x>0.55 && x<=0.8) {
        y = (-5.9460*Math.pow(x,3)) + (1.2779*Math.pow(10,1)*Math.pow(x,2)) + (-7.8315*x) + (1.9309)
      } else if (x>0.8 && x<=1) {
        y = (2.4853*Math.pow(x,3)) + (-7.4559*Math.pow(x,2)) + (8.3565*x) + (-2.3859)
      } else {
        y=x
      }

      // Inserted values are:
      // x, y
      // 0, 0
      // 0.1, 0.2
      // 0.55, 0.6
      // 0.8, 0.8
      // 1, 1

      if (x>=0 && x<=0.1) {
        y = (-1.1208*Math.pow(10,1)*Math.pow(x,3)) + (4.9421*Math.pow(10,-61)*Math.pow(x,2)) + (2.11121*x) + (0);
      } else if (x>0.1 && x<=0.55) {
        y = (3.0916*Math.pow(x,3)) + (-4.2898*Math.pow(x,2)) + (2.5411*x) + (-1.4299*Math.pow(10,-2))
      } else if (x>0.55 && x<=0.8) {
        y = (-4.9359*Math.pow(10,-1)*Math.pow(x,3)) + (1.6259*Math.pow(x,2)) + (-7.1254*Math.pow(10,-1)*x) + (5.8219*Math.pow(10,-1))
      } else if (x>0.8 && x<=1) {
        y = (-7.3544*Math.pow(10,-1)*Math.pow(x,3)) + (2.2063*Math.pow(x,2)) + (-1.1769*x) + (7.0602*Math.pow(10,-1))
      } else {
        y=x
      }

      // Inserted values are:
      // x, y
      // 0, 0
      // 0.1, 0.2
      // 0.55, 0.65
      // 0.8, 0.8
      // 1, 1

      if (x>=0 && x<=0.1) {
        y = (-8.7269*Math.pow(x,3)) + (1.1764*Math.pow(10,-60)*Math.pow(x,2)) + (2.0873*x) + (0);
      } else if (x>0.1 && x<=0.55) {
        y = (1.7416*Math.pow(x,3)) + (-3.1405*Math.pow(x,2)) + (2.4013*x) + (-1.0468*Math.pow(10,-2))
      } else if (x>0.55 && x<=0.8) {
        y = (2.2326*Math.pow(x,3)) + (-3.9507*Math.pow(x,2)) + (2.8469*x) + (-9.2166*Math.pow(10,-2))
      } else if (x>0.8 && x<=1) {
        y = (-2.3458*Math.pow(x,3)) + (7.0374*Math.pow(x,2)) + (-5.9436*x) + (2.2520)
      } else {
        y=x
      }

      return y
    }

    function getCollections() 
    {
      let collections = [
        {
          'n': 'Ultimo viene il corvo',
          'id': 'V002',
          'c': '#e9d05d'
        },
        {
          'n': 'L\'entrata in guerra',
          'id': 'V004',
          'c': '#12b259'
        },
        {
          'n': 'I racconti',
          'id': 'V006',
          'c': '#476a70'
        },
        {
          'n': 'Marcovaldo',
          'id': 'V011',
          'c': '#9f73b2'
        },
        {
          'n': 'Le cosmicomiche',
          'id': 'V013',
          'c': '#e89fc0'
        },
        {
          'n': 'Ti con zero',
          'id': 'V014',
          'c': '#581745'
        },
        {
          'n': 'La memoria del mondo',
          'id': 'V015',
          'c': '#00b1b3'
        },
        {
          'n': 'Gli amori difficili',
          'id': 'V017',
          'c': '#f0be96'
        },
        {
          'n': 'Palomar',
          'id': 'V022',
          'c': '#94d2ba'
        },
        {
          'n': 'Cosmicomiche vecchie e nuove',
          'id': 'V023',
          'c': '#f1634b'
        }
      ]

      return collections;
    }

    function incrementDrawMode(drawMode)
    {
      if(drawMode >= 4)
      {
        return 1;
      }
      else return drawMode + 1;
    }

    function prepareMetaballData(json_nodes, collection, lineColor)
    {
      let flattened_steps = flatten_items_steps(json_nodes);

      let hillBases = flattened_steps
        .filter(function(d) { 
          return d.first_elem && d.collections.includes(collection); 
      });

      let hillBase_circles = hillBases.map(hillBase => ({ 
          p: { x: hillBase.x, y: hillBase.y }, 
          r: hillBase.r * 1.2, 
          color: "blue",
          step: hillBase.step,
          id: hillBase.id }));
/*
      let hillBase_circles_map = new Map();

      for(let i = 0; i < hillBases.length; ++i)
      {
        let hillBase = hillBases[i];
        hillBase_circles_map[hillBase.id] = {
          p: { x: hillBase.x, y: hillBase.y },
          r: hillBase.r * 1.2,
          color: "blue"
        };
      }
*/
      let vertex_array = circles_to_vector_points(hillBase_circles);

      let alpha = 1000000;//150 * scale;
      let asq = alpha * alpha;

      var w = window.innerWidth;
      let h = window.innerHeight;

      let voronoi = d3.voronoi();

      let mesh = voronoi
        .triangles(vertex_array)
        .filter(
          function(t)
          {
            return (
              dsq(t[0], t[1]) < asq &&
              dsq(t[0], t[2]) < asq &&
              dsq(t[1], t[2]) < asq);
          });

      let boundary_points = boundary2(mesh);

      if(!borderOrientationIsCounterclockwise(boundary_points[0]))
      {
        boundary_points[0] = boundary_points[0].reverse();
      }

      boundary_points = addWantedCoves(vertex_array, boundary_points);

      if(boundary_points.length == 0) return;
/*
      mesh = voronoi
        .triangles(boundary_points[0])
        .filter(
          function(t)
          {
            return (
              dsq(t[0], t[1]) < asq &&
              dsq(t[0], t[2]) < asq &&
              dsq(t[1], t[2]) < asq);
          });      

      boundary_points = boundary(mesh);
*/
      let point_circle_map = new Map();

      for(let i = 0; i < hillBase_circles.length; ++i)
      {
        point_circle_map[vertex_array[i]] = hillBase_circles[i];
      }

      let ordered_boundary_circles = boundary_points[0]
        .slice(0, boundary_points_count(boundary_points))
        .map((point) => { 
          return point_circle_map[point]; 
        });

      let nCirclesToBeDrawn = ordered_boundary_circles.length;
//      let nCirclesToBeDrawn = 1;

      renderMetaballLogically(collection, ordered_boundary_circles, nCirclesToBeDrawn, lineColor);
    }

    function addWantedCoves(vertex_array, boundary_points)
    {
      if(boundary_points.length == 0) return [];

      if(boundary_points_count(boundary_points) <= 3) return boundary_points;

      let internal_points = arr_diff(vertex_array, boundary_points[0]);

      let new_boundary_points = [];

      for(let i = 0; i < boundary_points[0].length; ++i)
      {
        let next_index = i == boundary_points[0].length - 1 ? 0 : i + 1;

        let p1 = boundary_points[0][i];
        new_boundary_points.push(p1);

        let p2 = boundary_points[0][next_index];

        let boundary_dist = Math.sqrt(dsq(p1, p2));

        let cove_points = [];

        for(let i = 0; i < internal_points.length; ++i)
        {
          let ip = internal_points[i];

          let distSum = Math.sqrt(dsq(p1, ip)) + Math.sqrt(dsq(p2, ip));

          if(distSum / boundary_dist <= 1.2)
          {
            cove_points.push(ip);
          }
        }

        let pointsToBeAdded = findShortestPointsPath(p1, cove_points, p2);

        new_boundary_points = new_boundary_points.concat(pointsToBeAdded);

//        new_boundary_points.push(p2);
      }

      let result = [ new_boundary_points ];

      return result;
    }

    function findShortestPointsPath(p1, points, p2)
    {
      let leftShortestPath = [];
      let rightShortestPath = [];
      const nPoints = points.length;

      for(let i = 0; i < nPoints; ++i)
      {
        let distances = [];

        points.forEach(point => 
        { 
          distances.push({
            point: point,
            target: p1,
            distance: Math.sqrt(dsq(p1, point))
          });

          distances.push({
            point: point,
            target: p2,
            distance: Math.sqrt(dsq(point, p2))
          });
        });

        const nearest_point = distances.reduce(function(prev, current) {
          return (prev.distance < current.distance) ? prev : current;
        });

        if(nearest_point.target == p1)
        {
          leftShortestPath.push(nearest_point.point);
          p1 = nearest_point.point;
        }
        else
        {
          rightShortestPath.unshift(nearest_point.point);
          p2 = nearest_point.point;
        }

        points.splice(points.indexOf(nearest_point.point), 1);
      }

      let shortestPath = leftShortestPath.concat(rightShortestPath);

      return shortestPath;
    }

    function prepareMetaballs(json_nodes)
    {
/*      
      let flattened_steps = flatten_items_steps(json_nodes);

      let hillBases = flattened_steps
        .filter(function(d) { 
          return d.first_elem && d.collection == "V002"; 
      });

      let hillBases_array = hillBases.nodes();

      let hillBase_circles = hillBases_array.map(hillBase => ({ 
          p: { x: hillBase._parent.__data__.x, y: hillBase._parent.__data__.y }, 
          r: hillBase.__data__.r * 1.2, 
          color: "blue" }));

      let hillBase_circles_map = new Map();

      for(let i = 0; i < hillBases_array.length; ++i)
      {
        let hillBase = hillBases_array[i];
        hillBase_circles_map[hillBase.__data__.id] = {
          p: { x: hillBase._parent.__data__.x, y: hillBase._parent.__data__.y },
          r: hillBase.__data__.r * 1.2,
          color: "blue"
        };
      }

      let vertex_array = circles_to_vector_points(hillBase_circles);

      let alpha = 1000000;//150 * scale;
      let asq = alpha * alpha;

      var w = window.innerWidth;
      let h = window.innerHeight;

      let voronoi = d3.voronoi();

      let mesh = voronoi
        .triangles(vertex_array)
        .filter(
          function(t)
          {
            return (
              dsq(t[0], t[1]) < asq &&
              dsq(t[0], t[2]) < asq &&
              dsq(t[1], t[2]) < asq);
          });

      let boundary_points = boundary(mesh);      

      let point_circle_map = new Map();

      for(let i = 0; i < hillBase_circles.length; ++i)
      {
        point_circle_map[vertex_array[i]] = hillBase_circles[i];
      }

      let ordered_boundary_circles = boundary_points[0].slice(0, boundary_points.length - 2).map((point) => { return point_circle_map[point]; });

      //let nCirclesToBeDrawn = ordered_boundary_circles.length;
      let nCirclesToBeDrawn = 1;

      render(hillBases, ordered_boundary_circles, nCirclesToBeDrawn);
*/      
    }

    function renderMetaballLogically(collection, hillBaseCircles, nCirclesToBeDrawn, lineColor)
    {
      let nCircles = hillBaseCircles.length;

//      let svgContainer = d3.select("svg");

      for(let i = 0; i < nCirclesToBeDrawn; ++i)
      {
        let predecessorCircle = hillBaseCircles[i == 0 ? nCircles - 1 : i - 1];

        let centralCircle = hillBaseCircles[i];

        let successorCircle = hillBaseCircles[i < nCircles-1 ? i + 1 : 0];
/*
        hillBases
          .enter()
          .append("circle")
          .attr("cx", centralCircle.p.x)
          .attr("cy", centralCircle.p.y)
          .attr("r", 4)
          .attr("fill", centralCircle.color);
*/
        let lobe = metaball(predecessorCircle, centralCircle, successorCircle);
/*
        hillBases
          .append("svg:path")
          .attr("d", lobe)
          .attr("fill", "none")
          .attr("stroke", "red");
*/
/*
        centralCircle.step.metaballCorner = true;
        centralCircle.step.lobe = lobe;
        centralCircle.step.lobeColor = lineColor;
        centralCircle.step.x = centralCircle.p.x;
        centralCircle.step.y = centralCircle.p.y;
*/
        checkMapAndInsert(centralCircle.step, "metaballCorner", collection, true);
        checkMapAndInsert(centralCircle.step, "lobe", collection, lobe);
        checkMapAndInsert(centralCircle.step, "lobeColor", collection, lineColor);
        centralCircle.step.x = centralCircle.p.x;
        centralCircle.step.y = centralCircle.p.y;     

let a = 6;    
      }
    }

    function checkMapAndInsert(obj, mapName, key, value)
    {
      if(obj[mapName] == undefined) obj[mapName] = new Map();

      obj[mapName][key] = value;
    }

    function arr_diff(a1, a2) 
    {
/*      
        var a = [], diff = [];

        for(let i = 0; i < a1.length; ++i) 
        {
            a[a1[i]] = true;
        }

        for(let i = 0; i < a2.length; ++i) 
        {
          if(a[a2[i]]) 
          {
            delete a[a2[i]];
          } 
          else 
          {
            a[a2[i]] = true;
          }
        }

        for(var k in a) 
        {
          diff.push(k);
        }

        return diff;
*/

      let diff = [];

      for(let i = 0; i < a1.length; ++i)
      {
        let elem = a1[i];

        if(!a2.includesArray(elem))
        {
          diff.push(elem);
        }
      }

      return diff;
    }

    function array_intersection(a1, a2)
    {
      let result = [];

      if(a1 == undefined || a1.length == 0 || a2 == undefined || a2.length == 0) return result;

      for(let i = 0; i < a1.length; ++i)
      {
        let item = a1[i];

        if(a2.includes(item))
          result.push(item);
      }

      return result;
    }

    function render(hillBases, hillBaseCircles, nCirclesToBeDrawn)
    {
      let nCircles = hillBaseCircles.length;

      let svgContainer = d3.select("svg");

      for(let i = 0; i < nCirclesToBeDrawn; ++i)
      {
        let predecessorCircle = hillBaseCircles[i == 0 ? nCircles - 1 : i - 1];

        let centralCircle = hillBaseCircles[i];

        let successorCircle = hillBaseCircles[i < nCircles-1 ? i + 1 : 0];

        hillBases
          .enter()
          .append("circle")
          .attr("cx", centralCircle.p.x)
          .attr("cy", centralCircle.p.y)
          .attr("r", 4)
          .attr("fill", centralCircle.color);

        let lobe = metaball(predecessorCircle, centralCircle, successorCircle);

        hillBases
          .enter()
          .append("svg:path")
          .attr("d", lobe)
          .attr("fill", "none")
          .attr("stroke", "red");
      }
    }

    function angle(p1, p2)
    {
        let x = Math.atan2(p1.y - p2.y, p2.x - p1.x);

        return x;
    }

    function dist(p1, p2)
    {
        return Math.sqrt((p1.x - p2.x) * (p1.x - p2.x) + (p1.y - p2.y) * (p1.y - p2.y));
    }

    function normalizeNegativeAngle(angle)
    {
      while(angle < -Math.PI * 2)
      {
        angle += Math.PI;
      }

      return 2 * Math.PI + angle;
    }

    function normalizePositiveAngle(angle)
    {
      while(2 * Math.PI < angle)
      {
        angle -= 2 * Math.PI;
      }

      return angle;
    }

    function normalizeAngle(angle)
    {
      if(angle < 0) return normalizeNegativeAngle(angle);
      else return normalizePositiveAngle(angle);
    }

    function getCirclePoint(center, angle, radius)
    {
        return {
            x: center.x + Math.cos(angle) * radius,
            y: center.y - Math.sin(angle) * radius,
            center: center,
            angle: normalizeAngle(angle),
            radius: radius
        };
    }

    function getCircleJoint(
      circle1,
      circle2,
      v)
    {
      const center1 = circle1.p;
      const radius1 = circle1.r;
      const center2 = circle2.p;
      const radius2 = circle2.r;

      const d = dist(center1, center2);  

      let u1;

      if (d < radius1 + radius2) {
        u1 = Math.acos(
          (radius1 * radius1 + d * d - radius2 * radius2) / (2 * radius1 * d),
        );
      } else { // Else set u1 and u2 to zero
        u1 = 0;
      }  

      const angleBetweenCenters = angle(center1, center2);
      const maxSpread = Math.acos((radius1 - radius2) / d);

      const angle1 = angleBetweenCenters + u1 + (maxSpread - u1) * v;

      const p1 = getVector(center1, angle1, radius1);

      return p1;
    }

    function getCircleJoint2(
      circle1,
      circle2,
      v)
    {
      const angleBetweenCenters = angle(circle1.p, circle2.p);
      const distanceBetweenCenters = dist(circle1.p, circle2.p);

      const maxSpreadCalculated = Math.acos((circle1.r - circle2.r) / distanceBetweenCenters);
      const maxSpread = normalizeAngle(maxSpreadCalculated);
      const spread = maxSpread * circle1.r / (circle1.r + circle2.r) * 1.5;

      const jointAngle = normalizeAngle(angleBetweenCenters - spread);

      const joint = getCirclePoint(circle1.p, jointAngle, circle1.r);

      return joint;
    }

    function getCircleJoint3(
      circle1,
      circle2,
      v)
    {
      const angleBetweenCenters = angle(circle1.p, circle2.p);
      const distanceBetweenCenters = dist(circle1.p, circle2.p);

      const maxSpreadCalculated = Math.acos((circle1.r - circle2.r) / distanceBetweenCenters);
      const maxSpread = normalizeAngle(maxSpreadCalculated);
      const spread = maxSpread * circle1.r / (circle1.r + circle2.r) * 1.5;

      const jointAngle = normalizeAngle(angleBetweenCenters + spread);

      const joint = getCirclePoint(circle1.p, jointAngle, circle1.r);

      return joint;
    }

//function metaball(
//  center1, radius1, 
//  center2, radius2, 
//  handleSize = 2.4, 
//  v = 0.5) 

    function calculate_u(circle1, circle2)
    {
      const center1 = circle1.p;
      const radius1 = circle1.r;

      const center2 = circle2.p;
      const radius2 = circle2.r;

      const HALF_PI = Math.PI / 2;
      const d = dist(center1, center2);
      const maxDistFactor = 50; // 2.5
      const maxDist = (radius1 + radius2) * maxDistFactor;
      let u1, u2;

      // No blob if a radius is 0
      // or if distance between the circles is larger than max-dist
      // or if circle2 is completely inside circle1
      if (radius1 === 0 || radius2 === 0 || d > maxDist || d <= Math.abs(radius1 - radius2)) {
        return [0, 0];
      }

      // Calculate u1 and u2 if the circles are overlapping
      if (d < radius1 + radius2) {
        let u1Calculated = Math.acos(
          (radius1 * radius1 + d * d - radius2 * radius2) / (2 * radius1 * d),
        );
        u1 = normalizeAngle(u1Calculated);
        let u2Calculated = Math.acos(
          (radius2 * radius2 + d * d - radius1 * radius1) / (2 * radius2 * d),
        );
        u2 = normalizeAngle(u2Calculated);
      } else { // Else set u1 and u2 to zero
        u1 = 0;
        u2 = 0;
      }  

      return [u1, u2];
    }

    function metaball(
      predecessorCircle, 
      centralCircle, 
      successorCircle,
      handleSize = 2.4, 
      v = 0.5) 
    {
    //  const center1 = predecessorCircle.p;
    //  const radius1 = predecessorCircle.r;

    //  const center2 = centralCircle.p;
    //  const radius2 = centralCircle.r;
    /*
      const HALF_PI = Math.PI / 2;
      const d = dist(center1, center2);
      const maxDistFactor = 50; // 2.5
      const maxDist = (radius1 + radius2) * maxDistFactor;
      let u1, u2;

      // No blob if a radius is 0
      // or if distance between the circles is larger than max-dist
      // or if circle2 is completely inside circle1
      if (radius1 === 0 || radius2 === 0 || d > maxDist || d <= Math.abs(radius1 - radius2)) {
        return '';
      }

      // Calculate u1 and u2 if the circles are overlapping
      if (d < radius1 + radius2) {
        u1 = Math.acos(
          (radius1 * radius1 + d * d - radius2 * radius2) / (2 * radius1 * d),
        );
        u2 = Math.acos(
          (radius2 * radius2 + d * d - radius1 * radius1) / (2 * radius2 * d),
        );
      } else { // Else set u1 and u2 to zero
        u1 = 0;
        u2 = 0;
      }
    */
      // Calculate the max spread
    //  const angleBetweenCenters = angle(center1, center2);
    //  const maxSpread = Math.acos((radius1 - radius2) / d);

      const predecessorCentralCenterDistance = dist(predecessorCircle.p, centralCircle.p);

      const maxSpread = Math.cos((predecessorCircle.r - centralCircle.r) / predecessorCentralCenterDistance);

      let predecessorCentral_u_values = calculate_u(predecessorCircle, centralCircle);

      let u1 = predecessorCentral_u_values[0];
    //  let u2 = u_values[1];

      const angleBetweenPredecessorCentralCenters = angle(predecessorCircle.p, centralCircle.p);

      // Angles for the points
    //  const angle1 = angleBetweenCenters + u1 + (maxSpread - u1) * v;
      const angle1 = angleBetweenPredecessorCentralCenters + u1 + (maxSpread - u1) * v;

      let centralSuccessor_u_values = calculate_u(centralCircle, successorCircle);

    //  let u1 = predecessorCentral_u_values[0];
      let u2 = predecessorCentral_u_values[1];  
    //  let u2 = centralSuccessor_u_values[1];  

      const angleBetweenCentralSuccessorCenters = angle(centralCircle.p, successorCircle.p);

    //  const angle3 = angleBetweenCenters + Math.PI - u2 - (Math.PI - u2 - maxSpread) * v;
      const angle3 = normalizeAngle(-(angleBetweenPredecessorCentralCenters + Math.PI - u2 - (Math.PI - u2 - maxSpread) * v));
    //  const angle3 = angleBetweenCentralSuccessorCenters + Math.PI - u2 - (Math.PI - u2 - maxSpread) * v;

    //  const angle4 = angleBetweenCenters - Math.PI + u2 + (Math.PI - u2 - maxSpread) * v;

    let svgContainer = d3.select("svg");  

      // Point locations
    //  const p1 = getVector(center1, angle1, radius1);
      const p1 = getCircleJoint2(predecessorCircle, centralCircle, v);
/*
    svgContainer
      .append("circle")
      .attr("cx", p1.x)
      .attr("cy", p1.y)
      .attr("r", 4)
      .attr("fill", "black");
*/
    //  const p3 = getVector(center2, angle3, radius2);
    //  const p3 = getCirclePoint(centralCircle.p, angle3, centralCircle.r);
    //  const p3 = getCircleJoint(centralCircle, predecessorCircle, v);
      const p3 = getCircleJoint3(centralCircle, predecessorCircle, v);
/*
    svgContainer
      .append("circle")
      .attr("cx", p3.x)
      .attr("cy", p3.y)
      .attr("r", 4)
      .attr("fill", "gold");
*/
    //  const p4 = getVector(center2, angle4, radius2);
      const p4 = getCircleJoint2(centralCircle, successorCircle, v);
/*
    svgContainer
      .append("circle")
      .attr("cx", p4.x)
      .attr("cy", p4.y)
      .attr("r", 4)
      .attr("fill", "brown");
*/
      // Define handle length by the distance between both ends of the curve
    //  const totalRadius = radius1 + radius2;
      const totalRadius = predecessorCircle.r + centralCircle.r;

      const d2Base = Math.min(v * handleSize, dist(p1, p3) / totalRadius);

      // Take into account when circles are overlapping
    //  const d2 = d2Base * Math.min(1, d * 2 / (radius1 + radius2));
    //  const d2 = d2Base * Math.min(1, predecessorCentralCenterDistance * 2 / (predecessorCircle.r + centralCircle.r));

      // Length of the handles
    //  const r1 = radius1 * d2;
    //  const r1 = predecessorCircle.r * d2;

    //  const r2 = radius2 * d2;
    //  const r2 = centralCircle.r * d2;


      const HALF_PI = Math.PI / 2;  

      // Handle locations
    //  const h1 = getVector(p1, angle1 - HALF_PI, r1);
    //  const h1 = getCirclePoint(p1, angle1, predecessorCircle.r);
      const h1 = getCirclePoint(p1, HALF_PI + p1.angle, predecessorCircle.r);
/*
    svgContainer
      .append("rect")
      .attr("x", h1.x - 2)
      .attr("y", h1.y - 2)
      .attr("width", 4)
      .attr("height", 4)
      .attr("fill", "black");  
*/
    //  const h3 = getVector(p3, angle3 + HALF_PI, r2);
    //  const h3 = getCirclePoint(p3, angle3 + HALF_PI, centralCircle.r);
    //  const h3 = getCirclePoint(p3, angle3 - HALF_PI, centralCircle.r);
      const h3 = getCirclePoint(p3, p3.angle - HALF_PI, centralCircle.r);
/*
    svgContainer
      .append("rect")
      .attr("x", h3.x - 2)
      .attr("y", h3.y - 2)
      .attr("width", 4)
      .attr("height", 4)
      .attr("fill", "gold"); 
*/
      const p3_p4_angle = normalizeAngle(p4.angle - p3.angle);

    //  return metaballArc(p1, p3, p4, h1, h3, d > radius1, radius2);
      return metaballArc(p1, p3, p4, h1, h3, p3_p4_angle > Math.PI, centralCircle.r);
    }
  
    function metaballToPath(p1, p2, p3, p4, h1, h2, h3, h4, escaped, r) 
    {
      let s =
        'M' + p1.x + ' ' + p1.y + ' ' +
        cubic1Path(p3, h1, h3) +
        circleArcPath(p4, escaped, r) +
        cubic2Path(p2, h2, h4);

      return s;
    }

    function metaballArc(p1, p3, p4, h1, h3, largeArc, r)
    {
      let s =
        'M' + p1.x + ' ' + p1.y + ' ' +
        cubic1Path(p3, h1, h3)
        
        +
        circleArcPath(p4, largeArc, r);

      return s;
    }

    function cubic1Path(p3, h1, h3) 
    {
      return 'C' + h1.x + ' ' + h1.y + ', ' + h3.x + ' ' + h3.y + ', ' + p3.x + ' ' + p3.y + ' ';
    }

    function circleArcPath(p4, escaped, r) 
    {
      return 'A' + r + ' ' + r + ' ' + 0 + ' ' + (escaped ? 1 : 0) + 0 + ' ' + p4.x + ' ' + p4.y + ' ';
    }

    function circleArcPath2(p4, largeArc, r)
    {
      return 'A' + r + ' ' + r + ' ' + 0 + ' ' + (largeArc ? 1 : 0) + ' ' + 0 + ' ' + p4.x + ' ' + p4.y + ' ';
    }

    function cubic2Path(p2, h2, h4) 
    {
      return 'C' + h4.x + ' ' + h4.y + ', ' + h2.x + ' ' + h2.y + ', ' + p2.x + ' ' + p2.y;
    }

    function offset_circles(circles, dx, dy)
    {
        return circles.map((circle) => { return { p: { x: circle.p.x + dx, y: circle.p.y + dy }, r: circle.r, color: circle.color }; });
    }

    function circles_to_vector_points(circles)
    {
      return circles.map((circle) => { 
        let coords = [ circle.p.x, circle.p.y ];
        coords.id = circle.id;
        return coords;
      });
    }

    function vectorPoint_to_namedCoordPoint(point)
    {
      return { x: point[0], y: point[1] };
    }

    function ascendingCoords(a, b)
    {
        return a[0] === b[0] ? b[1] - a[1] : b[0] - a[0];
    }

    function offset_vector_points(vector_points, dx, dy)
    {
        return vector_points.map((vector_point) => { return [vector_point[0] + dx, vector_point[1] + dy]; });
    }

    function dsq(a, b) 
    {
        const dx = a[0] - b[0];
        const dy = a[1] - b[1];

        return dx * dx + dy * dy;
    }

    function boundary(mesh)
    {
      let counts = {};
      let edges = {};
      let r;
      let result = [];

      mesh.forEach(
        function(triangle)
        {
          for(let i = 0; i < 3; ++i)
          {
            let edge = [ triangle[i], triangle[(i + 1) % 3]].sort(ascendingCoords).map(String);
            (edges[edge[0]] = (edges[edge[0]] || [])).push(edge[1]);
            (edges[edge[1]] = (edges[edge[1]] || [])).push(edge[0]);
            let k = edge.join(":");
            if(counts[k]) delete counts[k];
            else counts[k] = 1;
          }
        });

      while(1)
      {
        let k = null;

        for(k in counts) break;

        if(k == null) break;

        result.push(r = k.split(":").map(function(d) { return d.split(",").map(Number); }));
        delete counts[k];

        let q = r[1];

        while(q[0] !== r[0][0] || q[1] !== r[0][1])
        {
          let p = q;
          let qs = edges[p.join(",")];
          let n = qs.length;

          for(let i = 0; i < n; ++i)
          {
            q = qs[i].split(",").map(Number);

            let edge = [p, q].sort(ascendingCoords).join(":");

            if(counts[edge])
            {
              delete counts[edge];
              r.push(q);

              break;
            }
          }
        }
      }

      return result;
    }

    function boundary2(mesh)
    {
      let counts = {};
      let edges = {};
      let r;
      let result = [];
      let pointMap = new Map();

      mesh.forEach(
        function(triangle)
        {
          for(let i = 0; i < 3; ++i)
          {
            let edge = [ triangle[i], triangle[(i + 1) % 3]].sort(ascendingCoords).map(point => { pointMap[point.id] = point; return point.id; });

            edges[edge[0]] = (edges[edge[0]] || []);

            if(!edges[edge[0]].includes(edge[1]))
              edges[edge[0]].push(edge[1]);

            edges[edge[1]] = (edges[edge[1]] || []);

            if(!edges[edge[1]].includes(edge[0]))
              edges[edge[1]].push(edge[0]);

            let k = edge.sort().join(":");
            if(counts[k]) delete counts[k];
            else counts[k] = 1;
          }
        });

      while(1)
      {
        let k = null;

        for(k in counts) break;

        if(k == null) break;

        result.push(r = k.split(":"));
        delete counts[k];

        let q = r[1];

        while(q !== r[0])
        {
          let p = q;
          let qs = edges[p];
          let n = qs.length;

          for(let i = 0; i < n; ++i)
          {
            q = qs[i];

            let edge = [p, q].sort().join(":");

            if(counts[edge])
            {
              delete counts[edge];
              r.push(q);

              break;
            }
          }
        }
      }

      let transformed_array = r.map(id => pointMap[id]);

      return [ transformed_array ];
    }

    function boundary_points_count(boundary_points)
    {
      return boundary_points[0].length - 1;
    }

    function pointsBarycenter(points)
    {
      const barycenter =
      {
        x: points.reduce((p1, p2) => ({ x: p1.x + p2.x })).x / points.length,
        y: points.reduce((p1, p2) => ({ y: p1.y + p2.y })).y / points.length
      };

      return barycenter;
    }

    // returns true for counterclockwise, false for clockwise
    function borderOrientationIsCounterclockwise(points)
    {
      const namedCoordPoints = points.map(vectorPoint_to_namedCoordPoint);

      const barycenter = pointsBarycenter(namedCoordPoints);  

      const angles = namedCoordPoints.map(point => normalizeAngle(angle(barycenter, point)));      

      const minAngle = Math.min(...angles);

      const indexOfMin = angles.indexOf(minAngle);

//      let angles2 = angles.rotate(-indexOfMin);
      angles.unshift(angles.splice(-indexOfMin, this.length));

      return angles[2] > angles[1];
    }

  </script>
</body>

</html>

