<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <style>

    svg {
      cursor: grab;
    }

    svg:active {
      cursor: grabbing;
    }

    .node {
      cursor: pointer;
    }
    .node .label {
      opacity: 0;
      transition: opacity .5s;
      pointer-events: none;
      font-family: sans-serif;
    }

    .node circle {
      /* shape-rendering: optimizeSpeed; */
    }
    .node:hover circle {
      /* fill:white; */
    }
    .node:hover .label {
      opacity: 1;
    }
    .g-circles {

    }
    .g-circles circle {

    }
  </style>
</head>
<body>
  <svg id="landscape">
    <defs>
      <filter id="goo">
        <feGaussianBlur in="SourceGraphic" stdDeviation="18" result="blur"></feGaussianBlur>
        <feColorMatrix in="blur" mode="matrix" result="mat" values="1 0 0 0 0  0 1 0 0 0  0 0 1 0 0  0 0 0 50 -19"></feColorMatrix>
      </filter>
    </defs>
  </svg>
  <!-- <p>Schiaccia "y" per colorare per anno, "c" per colorare per raccolta. "n" per evidenziare le opere della nebbia, "m" per cancellazione. Barra spaziatrice per tutte le opere.</p> -->
  <script src="https://d3js.org/d3.v5.js"></script>
  <script src="metaball.js"></script>
  <script type="text/javascript">
    let w = window.innerWidth-20
    let h = window.innerHeight-20
    let svg = d3.select('svg')
        .attr('width', w)
        .attr('height', h)
        .style('background-color','#e4e4e4')
        .style('background-color','#EFEBE9')

    d3.json("data.json").then(function(json){
      console.log(json.nodes)

      let nodes = json.nodes;

      nodes.forEach(function(n){
        // fix orientation of the viz
        // n.y*=-1;
        n.x*=-1;
        // handle collections
        if (n.attributes.collections){
          n.attributes.collections = n.attributes.collections.split(';')
          // remove last element which is always empty due to the fat that all records end with a ";"
          n.attributes.collections.pop()
        } else {
          n.attributes.collections = []
        }
      })
      // sort node so to have the upper in the background and not covering the ones in the foreground
      nodes = nodes.sort(function(a, b){return a.y - b.y})

      let collections = [
        {
          'n': 'Ultimo viene il corvo',
          'id': 'V002',
          'c': '#e9d05d'
        },
        {
          'n': 'L\'entrata in guerra',
          'id': 'V004',
          'c': '#12b259'
        },
        {
          'n': 'I racconti',
          'id': 'V006',
          'c': '#476a70'
        },
        {
          'n': 'Marcovaldo',
          'id': 'V011',
          'c': '#9f73b2'
        },
        {
          'n': 'Le cosmicomiche',
          'id': 'V013',
          'c': '#e89fc0'
        },
        {
          'n': 'Ti con zero',
          'id': 'V014',
          'c': '#581745'
        },
        {
          'n': 'La memoria del mondo',
          'id': 'V015',
          'c': '#00b1b3'
        },
        {
          'n': 'Gli amori difficili',
          'id': 'V017',
          'c': '#f0be96'
        },
        {
          'n': 'Palomar',
          'id': 'V022',
          'c': '#94d2ba'
        },
        {
          'n': 'Cosmicomiche vecchie e nuove',
          'id': 'V023',
          'c': '#f1634b'
        }
      ]

      let margin = {
        "min_x": d3.min(nodes, function(d){ return d.x }),
        "max_x": d3.max(nodes, function(d){ return d.x }),
        "min_y": d3.min(nodes, function(d){ return d.y }),
        "max_y": d3.max(nodes, function(d){ return d.y })
      }

      let colour = d3.scaleLinear()
          .domain(d3.extent(nodes, function(d){ return d.attributes.first_publication; }))
          .range(['#FADBD8','#B03A2E'])
          .range(['#CFD8DC','#455A64'])
          .range(['#ff6347','#455A64'])

      let col_collections = d3.scaleOrdinal()
          .domain(collections.map(function(d){return d.id}))
          .range(collections.map(function(d){return d.c}))
          .unknown('#d4d4d4')
          .unknown('#ffffff')

          // console.log(col_collections.domain())

      let metaballPoints = []
      collections.map(function(d){return d.id}).forEach(function(d){
        // console.log(d)
        let thisCollection = {
          'collection': d,
          'nodes': []
        }
        nodes.forEach(function(n){
          n.attributes.collections.forEach(function(c){
            if (c == d) {
              // console.log(c)
              thisCollection.nodes.push(n)
            }
          })
        })
        metaballPoints.push(thisCollection)
      })
      console.log('metaball points', metaballPoints)


      let g = svg.append('g')
          .append('g')
          .attr('class','nodes')

      // let metaballPolygon = g.selectAll('.polygon').data(metaballPoints).enter()
      //     .append('polygon')
      //     .classed('polygon', true)
      //     .attr('points', function(d){
      //       // console.log(d)
      //       let pointsHull = d3.polygonHull(d.nodes.map(function(d) { return [d.x,d.y]; }) )
      //       // console.log(polygonHull.join(' '))
      //       return pointsHull.join(' ')
      //     })
      //     .attr('fill','none')
      //     .attr('stroke', function(d){ return col_collections(d.collection) })
      //     .attr('stroke-width', 5)
      //     .attr('transform',function(d){
      //       return 'scale(1,0.5773)'
      //     })

      // let gMetaball = g.selectAll('.g-circles').data(metaballPoints).enter()
      //     .append('g')
      //     .classed('g-circles', true)
      //     .attr('fill', function(d){ return col_collections(d.collection) })
      //     .attr('opacity', .5)
      //     .attr("filter","url(#goo)")
      //
      // let pointsHull;
      // let circleMetaball = gMetaball.selectAll('circle').data(function(d){
      //       d.nodes.forEach(function(n){ n.thisCollection = d.collection });
      //       pointsHull = d3.polygonHull(d.nodes.map(function(d) { return [d.x,d.y]; }) )
      //         .map((d)=>{ return {'x':d[0], 'y':d[1]} })
      //       pointsHull.forEach((ph)=>{
      //         let filteredNodes = d.nodes.filter((n)=>{
      //           return ph.x == n.x && ph.y == n.y
      //         })
      //         ph.size = filteredNodes[0].size;
      //         ph.id = filteredNodes[0].id;
      //       })
      //       // console.log(d.collection, pointsHull)
      //       // return pointsHull
      //       return d.nodes
      //     }).enter()
      //     .append('circle')
      //     .attr('r', function(d){
      //       return d.size*4
      //     })
      //     .attr('cx', function(d){ return d.x })
      //     .attr('cy', function(d){ return d.y })
      //     .attr('transform',function(d){
      //       return 'scale(1,0.5773)'
      //     })

      // pointsHull.forEach((d,i)=>{
      //   console.log(d)
      //   let radius1 = pointsHull[i].size*2
      //   let center1 = pointsHull[i].size*2
      //   let path =  metaball(radius1, radius2, center1, center2)
      // })

      console.log(metaball(30, 60, [0,0], [200,200]))


      // Hills
      let node = g.selectAll('.node').data(nodes).enter()
          .append('g')
          .attr('class','node')
          .attr('transform',function(d){
            return 'scale(1,0.5773) translate('+d.x+','+d.y+')'
          })

      // calculate the size of steps for hills
      let size_ext = d3.extent(json.nodes, function(d){return d.size});
      let min_size = size_ext[0]/8;
      let step_increment = -23;

      function interpolateSpline(x) {
        let y;

        // The cubic spline interpolation has been calculated "heuristically" by using this service:
        // https://tools.timodenk.com/cubic-spline-interpolation

        // Inserted values are:
        // x, y
        // 0, 0
        // 0.2, 0.25
        // 0.5, 0.5
        // 0.8, 0.75
        // 1, 1

        if (x>=0 && x<=0.2) {
          y = (-2.0833*Math.pow(x,3)) + (1.25*Math.pow(10,-61)*Math.pow(x,2)) + (1.3333*x);
        } else if (x>0.2 && x<=0.5) {
          y = (1.3889*Math.pow(x,3)) + (-2.0833*Math.pow(x,2)) + (1.75*x) + (-2.7778*Math.pow(10,-2))
        } else if (x>0.5 && x<=0.8) {
          y = (1.3889*Math.pow(x,3)) + (-2.0833*Math.pow(x,2)) + (1.75*x) + (-2.7778*Math.pow(10,-2))
        } else if (x>0.8 && x<=1) {
          y = (-2.0833*Math.pow(x,3)) + (6.25*Math.pow(x,2)) + (-4.9167*x) + (1.75)
        } else {
          y=x
        }

        // Inserted values are:
        // x, y
        // 0, 0.1
        // 0.15, 0.30
        // 0.6, 0.6
        // 0.8, 0.75
        // 1, 1

        if (x>=0 && x<=0.15) {
          y = (-4.1854*Math.pow(x,3)) + (-1.0594*Math.pow(10,-60)*Math.pow(x,2)) + (1.4275*x) + (1*Math.pow(10,-1));
        } else if (x>0.15 && x<=0.6) {
          y = (1.8233*Math.pow(x,3)) + (-2.7039*Math.pow(x,2)) + (1.8331*x) + (7.9721*Math.pow(10,-2))
        } else if (x>0.6 && x<=0.8) {
          y = (1.9208*Math.pow(x,3)) + (-2.8793*Math.pow(x,2)) + (1.9383*x) + (5.8671*Math.pow(10,-2))
        } else if (x>0.8 && x<=1) {
          y = (-2.8842*Math.pow(x,3)) + (8.6525*Math.pow(x,2)) + (-7.2871*x) + (2.5188)
        } else {
          y=x
        }

        // Inserted values are:
        // x, y
        // 0, 0
        // 0.13, 0.2
        // 0.5, 0.5
        // 0.8, 0.75
        // 1, 1

        if (x>=0 && x<=0.13) {
          y = (-6.0237*Math.pow(x,3)) + (1*Math.pow(10,-61)*Math.pow(x,2)) + (1.6403*x) + (0);
        } else if (x>0.13 && x<=0.5) {
          y = (2.5213*Math.pow(x,3)) + (-3.3326*Math.pow(x,2)) + (2.0735*x) + (-1.8773*Math.pow(10,-2))
        } else if (x>0.5 && x<=0.8) {
          y = (7.3971*Math.pow(10,-1)*Math.pow(x,3)) + (-6.6014*Math.pow(10,-1)*Math.pow(x,2)) + (7.3729*Math.pow(10,-1)*x) + (2.0393*Math.pow(10,-1))
        } else if (x>0.8 && x<=1) {
          y = (-1.8586*Math.pow(x,3)) + (5.5759*Math.pow(x,2)) + (-4.2515*x) + (1.5343)
        } else {
          y=x
        }

        // Inserted values are:
        // x, y
        // 0, 0
        // 0.1, 0.2
        // 0.55, 0.5
        // 0.8, 0.8
        // 1, 1

        if (x>=0 && x<=0.1) {
          y = (-1.6169*Math.pow(10,1)*Math.pow(x,3)) + (-8.4013*Math.pow(10,-61)*Math.pow(x,2)) + (2.1617*x) + (0);
        } else if (x>0.1 && x<=0.55) {
          y = (5.7918*Math.pow(x,3)) + (-6.5882*Math.pow(x,2)) + (2.8205*x) + (-2.1961*Math.pow(10,-2))
        } else if (x>0.55 && x<=0.8) {
          y = (-5.9460*Math.pow(x,3)) + (1.2779*Math.pow(10,1)*Math.pow(x,2)) + (-7.8315*x) + (1.9309)
        } else if (x>0.8 && x<=1) {
          y = (2.4853*Math.pow(x,3)) + (-7.4559*Math.pow(x,2)) + (8.3565*x) + (-2.3859)
        } else {
          y=x
        }

        // Inserted values are:
        // x, y
        // 0, 0
        // 0.1, 0.2
        // 0.55, 0.6
        // 0.8, 0.8
        // 1, 1

        if (x>=0 && x<=0.1) {
          y = (-1.1208*Math.pow(10,1)*Math.pow(x,3)) + (4.9421*Math.pow(10,-61)*Math.pow(x,2)) + (2.11121*x) + (0);
        } else if (x>0.1 && x<=0.55) {
          y = (3.0916*Math.pow(x,3)) + (-4.2898*Math.pow(x,2)) + (2.5411*x) + (-1.4299*Math.pow(10,-2))
        } else if (x>0.55 && x<=0.8) {
          y = (-4.9359*Math.pow(10,-1)*Math.pow(x,3)) + (1.6259*Math.pow(x,2)) + (-7.1254*Math.pow(10,-1)*x) + (5.8219*Math.pow(10,-1))
        } else if (x>0.8 && x<=1) {
          y = (-7.3544*Math.pow(10,-1)*Math.pow(x,3)) + (2.2063*Math.pow(x,2)) + (-1.1769*x) + (7.0602*Math.pow(10,-1))
        } else {
          y=x
        }

        // Inserted values are:
        // x, y
        // 0, 0
        // 0.1, 0.2
        // 0.55, 0.65
        // 0.8, 0.8
        // 1, 1

        if (x>=0 && x<=0.1) {
          y = (-8.7269*Math.pow(x,3)) + (1.1764*Math.pow(10,-60)*Math.pow(x,2)) + (2.0873*x) + (0);
        } else if (x>0.1 && x<=0.55) {
          y = (1.7416*Math.pow(x,3)) + (-3.1405*Math.pow(x,2)) + (2.4013*x) + (-1.0468*Math.pow(10,-2))
        } else if (x>0.55 && x<=0.8) {
          y = (2.2326*Math.pow(x,3)) + (-3.9507*Math.pow(x,2)) + (2.8469*x) + (-9.2166*Math.pow(10,-2))
        } else if (x>0.8 && x<=1) {
          y = (-2.3458*Math.pow(x,3)) + (7.0374*Math.pow(x,2)) + (-5.9436*x) + (2.2520)
        } else {
          y=x
        }

        return y
      }

      let steps = node.selectAll('circle')
          .data(function(d){
            // reverse the order of collections, so to have the older ones at the bottom of the hills
            d.attributes.collections = d.attributes.collections.reverse()

            d.steps = []
            // get different radii
            for (var jj = (min_size); jj<= d.size; jj+=min_size) {
              let new_step_size = jj;
              let ratio = new_step_size / d.size;
              new_step_size = d.size * interpolateSpline(ratio);
              d.steps.push(new_step_size);
            }

            // get colors
            d.steps = d.steps.map((s,i)=>{

              // assign to each step a collection
              let pos_1 = i/d.steps.length;
              let pos_2 = pos_1 * d.attributes.collections.length;
              let collection_here = d.attributes.collections[Math.floor(pos_2)]

              return {'r': s, 'collection': collection_here, 'first_publication': d.attributes.first_publication, 'id': d.id}
            });

            // sort array so to have little circles on top, big at bottom
            d.steps = d.steps.reverse()

            return d.steps
          })
        .enter()
          .append('circle')
          .attr('stroke','#444')
          .attr('stroke-width',1.5)
          .attr('fill',function(d){
            // return colour(d.first_publication)
            // return 'transparent'
            return col_collections(d.collection)
          })
          // .style('shape-rendering','crispedges')
          .attr('r',function(d){ return d.r })
          // .style('opacity',0)
          // .transition()
          // .duration(1000)
          // .delay(function(d){return (d.first_publication - 1940)*100})
          .attr('transform', function(d,i){
            i = i*step_increment
            return 'translate(0,'+i+')'
          })
          // .style('opacity',1)

      // let linesExp = node.selectAll('.line-exp')
      //       .data(function(d){ return d.steps })
      //     .enter()
      //       .filter(function(d){ return d.id == 'V021'})
      //       .append('line')
      //       .attr('class','line-exp')
      //       .attr('stroke','#444')
      //       .attr('stroke-width',1.5)
      //       .attr('x1', function(d){
      //         return -d.r+d.r*0.2
      //       })
      //       .attr('y1', function(d){ return -d.r })
      //       .attr('x2', function(d){
      //         return -d.r+d.r*0.2
      //       })
      //       .attr('y2', function(d){ return d.r })
      //       .attr('transform', function(d,i){
      //         i = i*step_increment
      //         return 'translate(0,'+i+')'
      //       })

      let label = node.selectAll('.label')
            .data(function(d){ return [d] })
          .enter()
            .append('text')
            .attr('class','label')
            .attr('fill','black')
            .attr('font-size','5rem')
            .attr('transform',function(d){
              return 'translate(0,'+(d.steps.length+2)*step_increment+') scale(1,'+1/0.5773+')'
            })
            .text(function(d){
              return d.attributes.title;
              return d.id+'-'+d.attributes.title+'-'+d.attributes.first_publication;
            })

      node
        .on("Xmouseenter", function(){
          d3.selectAll('.node')
            .transition()
            .duration(350)
            .style('opacity',.4)

          d3.select(this)
            // .transition()
            // .duration(350)
            // .style('opacity',1)
            .selectAll('circle')
            .transition()
            .duration(350)
            .attr('transform', function(d,i){
              i = i*step_increment*1.5
              return 'translate(0,'+i+')'
            })
        })
        .on("Xmouseleave", function(){
          d3.selectAll('.node')
            .transition()
            .duration(350)
            .style('opacity',1)

          d3.select(this).selectAll('circle')
            .transition()
            .duration(350)
            .style('opacity',1)
            .attr('transform', function(d,i){
              i = i*step_increment
              return 'translate(0,'+i+')'
            })
        })



      //add zoom capabilities
      var zoom_handler = d3.zoom()
          .on("zoom", zoom_actions);

      zoom_handler(svg);

      svg.transition()
        .duration(0)
        .call( zoom_handler.transform, d3.zoomIdentity
          .translate(w/2,h/2*1.2)
          .scale(0.08)
        ); // updated for d3 v4

      //Zoom functions
      function zoom_actions(){
        // console.log(d3.event.transform)
        g.attr("transform", d3.event.transform)
      }

      d3.select('body').on("keyup", function(d) {
          // console.log(d3.event.key)
          if (d3.event.key == "c") {
            node.selectAll('circle')
              .transition().duration(350)
              .attr('fill',function(d){
                return col_collections(d.collection)
              })
          } else if (d3.event.key == "y") {
            node.selectAll('circle')
              .transition()
              .duration(350)
              .attr('fill',function(d){
                return colour(d.first_publication)
              })
          } else if (d3.event.key == "n") {
            node.style('display','none')
            node.filter(function(d){
                console.log(d)
                return d.attributes.nebbia
              })
              .style('display','block')
          } else if (d3.event.key == "m") {
            node.style('display','none')
            node.filter(function(d){
                console.log(d)
                return d.attributes.cancellazione
              })
              .style('display','block')
          }
          else if (d3.event.key == " ") {
           node.style('display','block')
         }
      })

    })



  </script>
</body>

</html>
